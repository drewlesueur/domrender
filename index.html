<!doctype html>
<html>
<style>
  * {
    font-family: 'Helvetica'; 
  }

  .container {
    width: 640px; 
    margin: auto; 
    text-align: center;
  }

  h1 {
    font-size: 60px;
    margin-bottom: 15px;
  }

  a {
  }

  p {
    line-height: 1.5em;
  }

  code {
    font-family: 'Courier'; 
    background-color: #eee;
  }

  pre {
    font-size: 14px;
    text-align: left;
    font-family: 'Courier'; 
    background-color: lightgray;
    padding: 10px;
  }

  pre span, pre a {
    font-size: 14px;
    text-align: left;
    font-family: 'Courier'; 
  }

  .step-note {
    color: #906; 
  }

  .examples a {
    display: block;
  }

  .comparison {
    border-collapse: collapse;
    border: 1px solid black;
  }
  .comparison td, .comparison th {
    padding: 10px;
    border: 1px solid black;
  }


</style>
<body>
<div class="container">
<h1>Domrender</h1>
<p>An HTML view library in under 500 lines.</p>
<p>Similar to React, but a lot smaller.</p>
<a href="https://github.com/drewlesueur/domrender">Source on GitHub</a>
<h2>How to use</h2>
<pre>
&lt;!doctype html&gt;
&lt;html&gt;
&lt;body&gt;

<span class="step-note">&lt;!-- Step 1. Include domrender.js --&gt;</span>
<span class="step">&lt;script src="<a href="domrender.js">domrender.js</a>"&gt;&lt;/script&gt;</span>

<span class="step-note">&lt;!-- Step 2. Make a template in html --&gt;</span>
<span class="step">&lt;div id="click-app"&gt;
  &lt;button @e onclick="handleClick()"&gt;Click Me&lt;/button&gt;
  &lt;br&gt;
  You clicked the button &lt;span @v=clicks&gt;&lt;/span&gt; times.
&lt;/div&gt;</span>

&lt;script&gt;
<span class="step-note">// Step 3. Make a JavaScript model</span>
<span class="step">var myClickApp = {
  clicks: 0,
  handleClick: function () {
    myClickApp.clicks += 1    
    myView.render() // call render after update
  }
}</span>

<span class="step-note">// Step 4. Bind the model to the dom element</span>
var el = document.getElementById("click-app")
var myView = domrender.use(el, myClickApp)

&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>

<h2>Live Demo</h2>
<div>
<script src="domrender.js"></script>

<div id="click-app" style="background-color: #eee; width: 320px; padding: 10px; margin: auto;">
  <button @e onclick="handleClick()">Click Me</button>
  <br>
  You clicked the button <span @v=clicks></span> times.
  <br><br>
  <a href="demos/hello_world.html">See demo standalone</a>  
</div>

<h2>More Examples</h2>
<div class="examples">
<a href="demos/text_html.html">Text and raw html with input binding</a>
<a href="demos/attributes.html">Attributes with more form element binding</a>
<a href="demos/loops.html">Loops with events</a> 
<a href="demos/components.html">Expressions and components</a>
<a href="demos/img.html">Images</a>
<a href="demos/radio.html">Radio buttons</a>
<a href="demos/loop_inputs.html">Loop with bound inputs</a>
<a href="demos/input.html">onreceive handler</a>

<h2>Examples Coming Soon</h2>
<a>Todo App</a>
</div>


<h2>Concepts</h2>
<p style="text-align: left;">
Domrender is inspired by Riot and React.
Like Riot and React, you can think updates in Domrender as "re-render-the-world".
Where React uses the virtual dom diffing approach, Riot uses a value diffing approach.*
Like Riot, Domrender also uses a value diffing approach, but does not require any compiling of <code>.tag</code> files.
Domrender just uses your existing dom. In Domrender, when <code>render()</code> is called, it will reevaluate
all the expressions that are bound to the dom, and then update the dom if needed.
</p>
<p style="text-align: left;">
Another difference is that Domrender does not do anyting special with event handling.
Old-fashoned inline (<code>onclick=</code> style) events are
obvious and easy to debug. Domrender does give you a helpful feature (via the <code>@e</code> attribute) that lets
your inline event handlers have the same scope as the javascript object they are bound to. For example, in the live demo above,
you can say <code>onclick="handleClick()"</code> instead of <code>onclick="myClickApp.handleClick()"</code>.

<br>
<span style="font-size: 0.5em">*This is my understanding of Riot.</span>
</p>

<h2>Other view libraries</h2>
<div class="examples">
<a href="http://vuejs.org/">Vue.js</a>
<a href="https://facebook.github.io/react/">React</a>
<a href="http://riotjs.com/">Riot</a>
<a href="https://angularjs.org/">Angular</a>
<a href="http://www.ractivejs.org/">Ractive</a>
<a href="http://rivetsjs.com/">Rivets</a>
<a href="http://emberjs.com/">Ember</a>
<a href="https://www.polymer-project.org/1.0/">Polymer</a>
<a href="https://x-tag.readme.io/">x-tag</a>
<a href="http://webcomponents.org/">web components</a>
</div>

</tbody>
</table>

<script>
// Step 3. Make a javascript model
var myClickApp = {
  clicks: 0,
  handleClick: function () {
    myClickApp.clicks += 1    
    myView.render() // call render after update
  }
}

// Step 4. bind the model to the dom element
var el = document.getElementById("click-app")
var myView = domrender.use(el, myClickApp)
</script>

</body>
</html>
</div>
</div>

</body>
</html>
